<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mr. Peebles, M.D.</title>
  <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
  <meta name="description" content="Watch clips from Mr. Peebles, M.D." />
  <meta name="theme-color" content="#ff6a00" />
  <style>
    :root{
      --bg:#f6f7fb; --card:#ffffff; --muted:#5b6470; --text:#111827; --brand:#ff6a00; --brand-2:#ff9533;
      --border:#e5e7eb; --radius:18px; --radius-sm:12px; --shadow:0 8px 24px rgba(16,24,40,.06);
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:var(--text); background:var(--bg)}
    a{color:inherit; text-decoration:none}
    header{position:sticky; top:0; backdrop-filter:saturate(140%) blur(8px); background:rgba(255,255,255,.8); border-bottom:1px solid var(--border); z-index:50}
    .wrap{max-width:1200px; margin:0 auto; padding:16px}
    header .wrap{padding:16px 16px 0}
    nav{display:flex; align-items:flex-end; justify-content:space-between}
    .brand{display:flex; gap:12px; align-items:center}
    .brand img{height:200px; width:auto; object-fit:contain; display:block}

    .controls{display:grid; grid-template-columns:1.5fr 0.8fr; gap:12px; margin:22px auto; max-width:1200px}
    .control{background:var(--card); padding:10px 12px; border:1px solid var(--border); border-radius:var(--radius-sm); display:flex; gap:10px; align-items:center; box-shadow:var(--shadow)}
    .control input, .control select{width:100%; background:transparent; border:0; color:var(--text); outline:none}

    .grid{max-width:1200px; margin:0 auto 60px; display:grid; gap:16px; grid-template-columns:repeat(auto-fill,minmax(250px,1fr))}
    .card{background:var(--card); border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; box-shadow:var(--shadow); display:flex; flex-direction:column}
    .thumb{position:relative; background:#eef2ff; display:grid; place-items:center}
    .thumb img{width:100%; height:150px; object-fit:cover; display:block}
    .thumb .placeholder{width:100%; height:150px; display:grid; place-items:center; font-weight:800; letter-spacing:.3px; color:#9b4a00; background:radial-gradient(90% 120% at 20% 10%, rgba(255,106,0,.15), transparent), linear-gradient(135deg,#fff4ec,#f1f5f9)}
    .duration{position:absolute; right:8px; bottom:8px; background:rgba(17,24,39,.75); color:#fff; padding:2px 6px; border-radius:8px; font-size:.8rem}
    .meta{padding:12px}
    .meta h3{margin:0; font-size:1rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .play{margin:12px; padding:10px 12px; border-radius:10px; background:linear-gradient(180deg,var(--brand),var(--brand-2)); color:#1f1308; border:0; cursor:pointer; font-weight:800}
    .empty{color:var(--muted); text-align:center; padding:40px}

    dialog#player{width:min(980px,92vw); border:1px solid var(--border); padding:0; border-radius:16px; overflow:hidden; background:#ffffff; box-shadow:0 30px 80px rgba(0,0,0,.2)}
    dialog#player::backdrop{background:rgba(0,0,0,.4)}
    .player-header{display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#f3f4f6; border-bottom:1px solid var(--border)}
    .player-title{font-weight:700}
    .close{background:#fff; color:#111; border:1px solid var(--border); cursor:pointer; padding:6px 10px; border-radius:8px}
    video{width:100%; height:auto; display:block; background:#000}
    .player-meta{padding:10px 12px; color:#475569; background:#fafafa; border-top:1px solid var(--border)}

    footer{border-top:1px solid var(--border); color:#6b7280; background:#fff}
    footer .wrap{display:flex; gap:18px; justify-content:space-between; align-items:center}

    @media (max-width:720px){
      .controls{grid-template-columns:1fr}
      .brand img{height:56px}
      header .wrap{padding:12px 12px 0}
    }

    /* NEW badge */
    .badge-new{
      position:absolute;
      top:8px; left:8px;
      padding:2px 6px;
      font-size:.75rem;
      font-weight:800;
      letter-spacing:.3px;
      color:#fff;
      background:#dc2626; /* red-600 */
      border-radius:999px;
      box-shadow:0 2px 6px rgba(0,0,0,.15);
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <nav>
        <div class="brand">
          <img src="images/logo.png" alt="Mr. Peebles, M.D. logo" />
        </div>
      </nav>
    </div>
  </header>

  <section class="wrap" aria-label="Controls">
    <div class="controls">
      <label class="control" title="Search by filename">
        üîé <input id="q" type="search" placeholder="Search clips‚Ä¶ (e.g., hallway, blooper)" />
      </label>
      <label class="control" title="Sort order">
        ‚ÜïÔ∏è <select id="sort">
          <option value="newest">Newest first</option>
          <option value="oldest">Oldest first</option>
          <option value="az">A ‚Üí Z</option>
          <option value="za">Z ‚Üí A</option>
          <option value="longest">Longest first</option>
        </select>
      </label>
    </div>
  </section>

  <section class="grid" id="grid" aria-label="Clips grid"></section>
  <div class="empty" id="empty" hidden>No clips found in the folder.</div>

  <dialog id="player">
    <div class="player-header">
      <div class="player-title" id="playerTitle">Playing‚Ä¶</div>
      <button class="close" id="closePlayer" aria-label="Close">‚úï</button>
    </div>
    <video id="video" controls preload="metadata" poster=""></video>
    <div class="player-meta" id="playerMeta"></div>
  </dialog>

  <footer>
    <div class="wrap">
      <div>¬© <span id="year"></span> Mr. Peebles, M.D.</div>
    </div>
  </footer>

  <script>
    // ---- Configuration ----
    const CLIPS_DIR = 'videos/';
    const ACCEPT = ['.mp4', '.webm', '.m4v'];

    const GH_OWNER  = 'smcnys';
    const GH_REPO   = 'mrpeebles';
    const GH_BRANCH = 'main';

    // Optional: token to raise rate limit (leave '' for unauthenticated)
    const GH_TOKEN = ''; // e.g., 'ghp_xxxxxxxxxxxxxxxxxxxxx'
    const GH_HEADERS = {
      'Accept': 'application/vnd.github+json',
      ...(GH_TOKEN ? { 'Authorization': `Bearer ${GH_TOKEN}` } : {})
    };

    const $ = (s, el=document) => el.querySelector(s);
    const $$ = (s, el=document) => Array.from(el.querySelectorAll(s));
    const fmt = (n)=> n.toString().padStart(2,'0');
    const hms = (sec)=> `${Math.floor(sec/60)}:${fmt(Math.round(sec%60))}`;

    const grid = $('#grid');
    const empty = $('#empty');

    async function listFilesFromDirectory(dir){
      const ghItems = await tryGitHubAPI(dir);
      if (ghItems && ghItems.length) return ghItems;

      const manifest = await tryManifest(dir);
      if (manifest && manifest.length) return manifest;

      const htmlList = await tryHTMLListing(dir);
      if (htmlList && htmlList.length) return htmlList;

      return [];
    }

    function ownerFromHost(){
      const h = location.hostname; if(!h.endsWith('github.io')) return null;
      return h.split('.github.io')[0];
    }

    function repoFromPath(){
      const seg = location.pathname.split('/').filter(Boolean);
      return seg.length ? seg[0] : null;
    }

    async function tryGitHubAPI(dir){
      let owner = GH_OWNER || ownerFromHost();
      let repo  = GH_REPO  || repoFromPath();
      if(!owner || !repo) return null;

      const path = dir.replace(/^\/+|\/+$/g,'');
      const branches = [GH_BRANCH || 'gh-pages','main','master'];

      for (const br of branches){
        try{
          const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${encodeURIComponent(br)}`;
          const res = await fetch(url, { headers: GH_HEADERS });
          if(!res.ok) continue;
          const data = await res.json();
          const files = data
            .filter(x => x.type === 'file' && ACCEPT.some(ext => x.name.toLowerCase().endsWith(ext)))
            .map(x => ({ url: new URL(x.download_url).href, path: x.path, branch: br }));
          if(files.length) return files;
        }catch{ /* try next */ }
      }
      return null;
    }

    async function tryManifest(dir){
      try{
        const res = await fetch(dir.replace(/\/$/,'') + '/clips.json', {cache:'no-store'});
        if(!res.ok) return null;
        const arr = await res.json();
        return arr
          .filter(name => ACCEPT.some(ext => name.toLowerCase().endsWith(ext)))
          .map(name => {
            const url = new URL(name, location.origin + location.pathname.replace(/[^/]*$/,'') + dir).href;
            const guess = guessRepoPathFromUrl(url);
            return { url, path: guess.path, branch: guess.branch };
          });
      }catch{ return null }
    }

    async function tryHTMLListing(dir){
      try{
        const res = await fetch(dir, {headers:{'Accept':'text/html'}});
        if(!res.ok) return null;
        const text = await res.text();
        const doc = new DOMParser().parseFromString(text, 'text/html');
        const links = [...doc.querySelectorAll('a')]
          .map(a => a.getAttribute('href'))
          .filter(h => h && !h.startsWith('?') && !h.startsWith('#'))
          .map(h => decodeURIComponent(h));
        const files = links
          .filter(h => ACCEPT.some(ext => h.toLowerCase().endsWith(ext)))
          .map(h => {
            const url = new URL(h, res.url).href;
            const guess = guessRepoPathFromUrl(url);
            return { url, path: guess.path, branch: guess.branch };
          });
        return files;
      }catch{ return null }
    }

    // Try to recover repo path/branch from a file URL
    function guessRepoPathFromUrl(u){
      try{
        const url = new URL(u, location.href);

        // raw.githubusercontent.com/<owner>/<repo>/<branch>/...
        if(url.hostname === 'raw.githubusercontent.com'){
          const [, owner, repo, branch, ...rest] = url.pathname.split('/').filter(Boolean);
          return { path: rest.join('/'), branch };
        }

        // GitHub Pages or other static hosting: assume site path mirrors repo structure
        const idx = url.pathname.lastIndexOf(CLIPS_DIR);
        if(idx !== -1){
          const tail = url.pathname.slice(idx).replace(/^\/+/,'');
          return { path: tail, branch: (GH_BRANCH || 'gh-pages') };
        }
      }catch{}
      return { path: null, branch: (GH_BRANCH || 'gh-pages') };
    }

    // GitHub: latest commit that touched a file -> timestamp (ms)
    async function getGitHubLastCommitMs({ owner, repo, branch, path }){
      if(!owner || !repo || !branch || !path) return NaN;
      try{
        const api = `https://api.github.com/repos/${owner}/${repo}/commits?path=${encodeURIComponent(path)}&sha=${encodeURIComponent(branch)}&per_page=1`;
        const res = await fetch(api, { headers: GH_HEADERS });
        if(!res.ok) return NaN;
        const arr = await res.json();
        if(!Array.isArray(arr) || !arr.length) return NaN;
        const c = arr[0].commit;
        const iso = (c && (c.committer?.date || c.author?.date)) || null;
        return iso ? new Date(iso).getTime() : NaN;
      }catch{ return NaN }
    }

    // Fallback: get reliable last-modified timestamp (ms). HEAD first, then tiny ranged GET.
    async function headLastModifiedMs(url){
      try{
        const r = await fetch(url, { method:'HEAD' });
        const h = r.headers.get('last-modified');
        if (h) return new Date(h).getTime();
      }catch{}
      try{
        const r = await fetch(url, { method:'GET', headers:{ 'Range':'bytes=0-0' } });
        const h = r.headers.get('last-modified');
        if (h) return new Date(h).getTime();
      }catch{}
      return NaN;
    }

    async function getDuration(url){
      return new Promise((resolve) => {
        const v = document.createElement('video');
        v.preload = 'metadata';
        v.src = url;
        v.addEventListener('loadedmetadata', () => {
          resolve(isFinite(v.duration) ? v.duration : 0);
          v.remove();
        });
        v.addEventListener('error', ()=>{ resolve(0); v.remove(); });
      });
    }

    function decodedFilenameFrom(url){
      try{
        const u = new URL(url, location.href);
        const last = u.pathname.split('/').filter(Boolean).pop() || url;
        return decodeURIComponent(last);
      }catch{
        return url;
      }
    }

    function baseNoExt(filename){
      const i = filename.lastIndexOf('.');
      return i>0 ? filename.slice(0,i) : filename;
    }

    // ---------- Thumbnails (2‚Äì4s window) ----------
    const thumbCache = new Map();

    async function generateThumbnail(url, timeHintSec){
      if (thumbCache.has(url)) return thumbCache.get(url);

      const dataUrl = await new Promise((resolve) => {
        const v = document.createElement('video');
        v.crossOrigin = 'anonymous';
        v.muted = true;
        v.preload = 'auto';
        v.src = url;

        const pickThumbTime = (dur) => {
          if (!isFinite(dur) || dur <= 0) return 2; // best effort
          // If clip is shorter than ~2.2s, pick 20% in as a fallback.
          if (dur <= 2.2) return Math.max(0.1, Math.min(dur - 0.1, dur * 0.2));
          const minT = 2;
          const maxT = Math.min(4, dur - 0.1); // avoid seeking past end
          const desired = (typeof timeHintSec === 'number') ? timeHintSec : 3; // center of window
          return Math.min(Math.max(desired, minT), maxT);
        };

        const cleanup = () => { v.pause(); v.removeAttribute('src'); v.load(); v.remove(); };
        const onFail = () => { cleanup(); resolve(null); };

        v.addEventListener('error', onFail);
        v.addEventListener('loadedmetadata', () => {
          const t = pickThumbTime(v.duration);
          // Some browsers need a tiny delay before the first seek
          setTimeout(() => { v.currentTime = t; }, 0);
        });

        v.addEventListener('seeked', () => {
          try{
            const canvas = document.createElement('canvas');
            const w = v.videoWidth || 640;
            const h = v.videoHeight || 360;
            const targetH = 150;
            const targetW = Math.round((w / h) * targetH);
            canvas.width = targetW;
            canvas.height = targetH;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(v, 0, 0, targetW, targetH);
            const url = canvas.toDataURL('image/jpeg', 0.8);
            cleanup();
            resolve(url);
          }catch(e){
            onFail();
          }
        });
      });

      if (dataUrl) thumbCache.set(url, dataUrl);
      return dataUrl;
    }

    function placeholder(){
      const d = document.createElement('div');
      d.className = 'placeholder';
      d.textContent = 'Loading‚Ä¶';
      return d;
    }
    // -------------------------------

    function cardTemplate(item){
      const art = document.createElement('article');
      art.className = 'card';
      art.innerHTML = `
        <div class="thumb"></div>
        <div class="meta"><h3 title="${item.title}">${item.title}</h3></div>
        <button class="play">‚ñ∂ Play</button>`;
      const thumb = art.querySelector('.thumb');

      const ph = placeholder();
      thumb.appendChild(ph);

      // NEW! badge if clip is < 12 hours old (based on commit/lastModified time)
      const TWELVE_HOURS = 12 * 60 * 60 * 1000;
      const isNew = Number.isFinite(item.lastModifiedMs) && (Date.now() - item.lastModifiedMs) <= TWELVE_HOURS;
      if (isNew){
        const badge = document.createElement('div');
        badge.className = 'badge-new';
        badge.textContent = 'NEW!';
        badge.setAttribute('aria-label', 'New clip');
        thumb.appendChild(badge);
      }

      const dur = document.createElement('div');
      dur.className = 'duration';
      dur.textContent = item.duration ? hms(item.duration) : '';
      thumb.appendChild(dur);

      // Force thumbnail between 2‚Äì4s (default 3s), with fallbacks handled inside generateThumbnail
      generateThumbnail(item.url, 3)
        .then(dataUrl => {
          if (!dataUrl) return;
          const img = document.createElement('img');
          img.alt = item.title + ' thumbnail';
          img.src = dataUrl;
          ph.replaceWith(img);
        })
        .catch(()=>{});

      art.querySelector('.play').addEventListener('click', ()=> openPlayer(item));
      return art;
    }

    const dlg = document.getElementById('player');
    const video = document.getElementById('video');

    function openPlayer(item){
      document.getElementById('playerTitle').textContent = item.title;

      const last = Number.isFinite(item.lastModifiedMs) ? new Date(item.lastModifiedMs) : null;
      const metaBits = [];
      if (last) metaBits.push(last.toLocaleString());
      if (item.duration) metaBits.push(hms(item.duration));
      document.getElementById('playerMeta').textContent = metaBits.join(' ‚Ä¢ ');

      video.pause();
      video.removeAttribute('src');
      video.load();
      video.src = item.url;

      if (typeof dlg.showModal === 'function') dlg.showModal();

      const onMeta = () => {
        video.removeEventListener('loadedmetadata', onMeta);
        video.play().catch(()=>{});
      };
      video.addEventListener('loadedmetadata', onMeta, { once: true });
    }

    document.getElementById('closePlayer').addEventListener('click', () => {
      video.pause();
      video.removeAttribute('src');
      video.load();
      dlg.close();
    });

    function ghRepoInfo(){
      return {
        owner: GH_OWNER || ownerFromHost(),
        repo:  GH_REPO  || repoFromPath()
      };
    }

    async function main(){
      let rawList = await listFilesFromDirectory(CLIPS_DIR);

      // Normalize to objects { url, path, branch }
      const list = rawList.map(entry => {
        if(typeof entry === 'string'){
          const guess = guessRepoPathFromUrl(entry);
          return { url: entry, path: guess.path, branch: guess.branch };
        }
        return entry; // already {url, path, branch}
      });

      const { owner, repo } = ghRepoInfo();

      const items = await Promise.all(list.map(async (it) => {
        const fname = decodedFilenameFrom(it.url);
        const title = baseNoExt(fname);

        // Prefer GitHub last commit date if we can
        let commitMs = NaN;
        if(owner && repo && it.path){
          commitMs = await getGitHubLastCommitMs({ owner, repo, branch: it.branch || GH_BRANCH || 'main', path: it.path });
        }

        // Fallback to HTTP Last-Modified if commitMs failed
        const lastModMs = Number.isFinite(commitMs) ? commitMs : await headLastModifiedMs(it.url);

        const duration = await getDuration(it.url);
        return { url: it.url, filename: fname, title, lastModifiedMs: lastModMs, duration };
      }));

      state.all = items;
      render();
    }

    const state = { all:[], q:'', sort:'newest' };

    function render(){
      const q = ($('#q').value||'').toLowerCase();
      const sort = $('#sort').value;
      let list = state.all.filter(i => i.title.toLowerCase().includes(q));

      if (sort==='az') list.sort((a,b)=> a.title.localeCompare(b.title));
      if (sort==='za') list.sort((a,b)=> b.title.localeCompare(a.title));
      if (sort==='longest') list.sort((a,b)=> (b.duration||0) - (a.duration||0));

      if (sort==='newest'){
        list.sort((a,b)=>{
          const am = Number.isFinite(a.lastModifiedMs) ? a.lastModifiedMs : -Infinity;
          const bm = Number.isFinite(b.lastModifiedMs) ? b.lastModifiedMs : -Infinity;
          if(!Number.isFinite(a.lastModifiedMs) && !Number.isFinite(b.lastModifiedMs)) return 0;
          if(!Number.isFinite(a.lastModifiedMs)) return 1;  // a unknown -> after b
          if(!Number.isFinite(b.lastModifiedMs)) return -1; // b unknown -> after a
          return bm - am; // newest first
        });
      }

      if (sort==='oldest'){
        list.sort((a,b)=>{
          const am = Number.isFinite(a.lastModifiedMs) ? a.lastModifiedMs : +Infinity;
          const bm = Number.isFinite(b.lastModifiedMs) ? b.lastModifiedMs : +Infinity;
          if(!Number.isFinite(a.lastModifiedMs) && !Number.isFinite(b.lastModifiedMs)) return 0;
          if(!Number.isFinite(a.lastModifiedMs)) return 1;  // a unknown -> after b
          if(!Number.isFinite(b.lastModifiedMs)) return -1; // b unknown -> after a
          return am - bm; // oldest first
        });
      }

      grid.innerHTML = '';
      list.forEach(item => grid.appendChild(cardTemplate(item)));
      empty.hidden = list.length !== 0;
    }

    // Events: input for search, change for select
    document.getElementById('q').addEventListener('input', render);
    document.getElementById('sort').addEventListener('change', render);

    document.getElementById('year').textContent = new Date().getFullYear();

    // Close dialog with Escape
    document.addEventListener('keydown',(e)=>{ if(e.key==='Escape' && dlg.open){ dlg.close(); }});

    main().catch(err=>{
      console.error('Listing error:', err);
      empty.hidden=false;
      empty.textContent='No clips found (or directory listing disabled).';
    });
  </script>
</body>
</html>
